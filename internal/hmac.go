package internal

import (
	"crypto/hmac"
	"crypto/sha1"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type HMACComputer func(normalizedRequest, secret string) string

func ComputeHMAC256(normalizedRequest, secret string) string {
	key := []byte(secret)
	h := hmac.New(sha256.New, key)
	h.Write([]byte(normalizedRequest))
	return base64.StdEncoding.EncodeToString(h.Sum(nil))
}

func ComputeHMAC1(normalizedRequest, secret string) string {
	key := []byte(secret)
	h := hmac.New(sha1.New, key)
	h.Write([]byte(normalizedRequest))
	return base64.StdEncoding.EncodeToString(h.Sum(nil))
}

// Everything below is based on the following IETF draft for OAuth v2
// http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01#section-3.1

// IETF OAuth V2 draft:
// REQUIRED.  A unique string generated by the client.  The value
// MUST be unique across all requests with the same timestamp and
// MAC key identifier combination.
func getNonce(timestamp int64) string {
	hash := sha1.New()
	hash.Write([]byte(fmt.Sprintf("%s", timestamp)))
	return fmt.Sprintf("%x", hash.Sum(nil))
}

// IETF OAuth V2 draft:
// The HTTP request method in upper case.  For example: "HEAD",
// "GET", "POST", etc.
//
// NOTE: When Request.Method is empty, that means it is a GET
func getMethod(r *http.Request) string {
	method := strings.ToUpper(r.Method)
	if len(method) == 0 {
		method = "GET"
	}
	return method
}

// IETF OAuth V2 draft:
// The port as included in the HTTP request using the "Host" request
// header field.  If the header field does not include a port, the
// default value for the scheme MUST be used (e.g. 80 for HTTP and
// 443 for HTTPS).
//
// NOTE: Returning string since that is how it will be used later anyways
func getPort(r *http.Request) string {
	hostSlices := strings.Split(r.URL.Host, ":")

	if len(hostSlices) == 2 { // host contains port
		return hostSlices[1]
	} else if r.URL.Scheme == "https" {
		return "443"
	} else {
		return "80"
	}
}

// IETF OAuth V2 draft:
// The hostname included in the HTTP request using the "Host"
// request header field in lower case.
func getHostname(r *http.Request) string {
	hostSlices := strings.Split(r.URL.Host, ":")

	return strings.ToLower(hostSlices[0])
}

// IETF OAuth V2 draft:
// The HTTP request-URI as defined by [RFC2616] section 5.1.2.
func getRequestURI(r *http.Request) string {
	return r.URL.RequestURI()
}

// HMAC supports sha1 and sha256
func getEncryptor(algorithm string) HMACComputer {
	algorithm = strings.ToLower(algorithm)

	if algorithm == "hmac-sha-1" {
		return ComputeHMAC1
	} else if algorithm == "hmac-sha-256" {
		return ComputeHMAC256
	} else {
		panic("invalid hmac algorithm supplied")
	}
}

func getAuthHeader(accessToken, ts, nonce, mac string) string {
	formatStr := "MAC id=\"%s\", ts=\"%s\", nonce=\"%s\", mac=\"%s\""

	return fmt.Sprintf(formatStr, accessToken, ts, nonce, mac)
}

// this is such a piece of crap
func AddHMACOauthToHeader(r *http.Request, accessToken, macKey, macAlgorithm string) {
	timestampNano := time.Now().UnixNano()

	// Variables for the Normalized Request String
	ts := strconv.Itoa(int(timestampNano / 1000000000)) // 1e9
	nonce := getNonce(timestampNano)
	method := getMethod(r)
	requestURI := getRequestURI(r)
	hostname := getHostname(r)
	port := getPort(r)

	lines := []string{ts, nonce, method, requestURI, hostname, port}
	normalizedRequest := strings.Join(lines, "\n") + "\n\n"

	encryptor := getEncryptor(macAlgorithm)
	requestMAC := encryptor(normalizedRequest, macKey)

	r.Header.Set("Authorization", getAuthHeader(accessToken, ts, nonce, requestMAC))
}
